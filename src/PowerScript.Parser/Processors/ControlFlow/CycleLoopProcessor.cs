using PowerScript.Common.Logging;
using PowerScript.Core.AST;
using PowerScript.Core.AST.Expressions;
using PowerScript.Core.AST.Statements;
using PowerScript.Core.Exceptions;
using PowerScript.Core.Syntax.Tokens.Base;
using PowerScript.Core.Syntax.Tokens.Delimiters;
using PowerScript.Core.Syntax.Tokens.Identifiers;
using PowerScript.Core.Syntax.Tokens.Keywords;
using PowerScript.Core.Syntax.Tokens.Scoping;
using PowerScript.Core.Syntax.Tokens.Values;
using PowerScript.Parser.Processors.Base;

namespace PowerScript.Parser.Processors.ControlFlow;

/// <summary>
///     Processes CYCLE keyword for loops.
///     Syntax:
///     Count-based: CYCLE 5 { ... } or CYCLE 10 AS i { ... }
///     Collection-based: CYCLE IN collection { ... } or CYCLE IN collection AS variableName { ... }
///     Automatic index variables: A, B, C, D, ... based on nesting level (when AS is not specified)
/// </summary>
public class CycleLoopProcessor(IScopeBuilder scopeBuilder) : ITokenProcessor
{
    private readonly IScopeBuilder _scopeBuilder = scopeBuilder;

    public bool CanProcess(Token token)
    {
        return token is CycleKeywordToken;
    }

    public TokenProcessingResult Process(Token token, ProcessingContext context)
    {
        LoggerService.Logger.Info(
            $"[CycleLoopProcessor] Processing CYCLE loop in scope '{context.CurrentScope.ScopeName}'");

        CycleKeywordToken? cycleToken = token as CycleKeywordToken;
        Token? currentToken = cycleToken!.Next;

        Expression collectionExpression;
        string loopVariableName;
        int nestingLevel = context.CycleNestingDepth;
        bool isCountBased = false;
        bool isWhileLoop = false;
        bool isRangeLoop = false;
        bool usedAutoGeneratedName = false; // Track if we used an auto-generated name
        Expression? rangeStartExpression = null;
        Expression? rangeEndExpression = null;

        // Check for WHILE keyword first
        if (currentToken is WhileKeywordToken)
        {
            // CYCLE WHILE condition { ... } or CYCLE WHILE condition AS var { ... }
            isWhileLoop = true;
            currentToken = currentToken.Next;

            // Collect tokens for the while condition
            List<Token> conditionTokens = [];
            while (currentToken is not null and not ScopeStartToken and not AsKeywordToken)
            {
                conditionTokens.Add(currentToken);
                currentToken = currentToken.Next;
            }

            if (conditionTokens.Count == 0)
            {
                throw new UnexpectedTokenException(currentToken, "Expected condition expression after WHILE");
            }

            // Build the condition expression
            collectionExpression = BuildExpressionFromTokens(conditionTokens);
            loopVariableName = GetAutomaticIndexName(nestingLevel);
            usedAutoGeneratedName = true;

            LoggerService.Logger.Debug($"WHILE loop with condition: {string.Join(" ", conditionTokens.Select(t => t.RawToken?.Text))}");

            // Check for AS keyword
            if (currentToken is AsKeywordToken)
            {
                currentToken = currentToken.Next;

                if (currentToken is not IdentifierToken customNameToken)
                {
                    throw new UnexpectedTokenException(currentToken, typeof(IdentifierToken));
                }

                loopVariableName = customNameToken.RawToken!.Text;
                usedAutoGeneratedName = false;
                currentToken = currentToken.Next;

                LoggerService.Logger.Debug($"Custom loop variable name: {loopVariableName}");
            }
        }
        // Check for ELEMENTS keyword - CYCLE ELEMENTS OF collection
        else if (currentToken is ElementsKeywordToken)
        {
            currentToken = currentToken.Next;

            // Expect OF keyword
            if (currentToken is not OfKeywordToken)
            {
                throw new UnexpectedTokenException(currentToken, typeof(OfKeywordToken));
            }

            currentToken = currentToken.Next;

            // Parse the collection expression
            collectionExpression = ParseCollectionExpression(ref currentToken);

            LoggerService.Logger.Debug($"ELEMENTS OF collection: {collectionExpression}");

            loopVariableName = GetAutomaticIndexName(nestingLevel);
            usedAutoGeneratedName = true;

            // Check for AS keyword
            if (currentToken is AsKeywordToken)
            {
                currentToken = currentToken.Next;

                if (currentToken is not IdentifierToken customNameToken)
                {
                    throw new UnexpectedTokenException(currentToken, typeof(IdentifierToken));
                }

                loopVariableName = customNameToken.RawToken!.Text;
                usedAutoGeneratedName = false;
                currentToken = currentToken.Next;

                LoggerService.Logger.Debug($"Custom loop variable name: {loopVariableName}");
            }
        }
        // Check for RANGE keyword - CYCLE RANGE FROM start TO end
        else if (currentToken is RangeKeywordToken)
        {
            isRangeLoop = true;
            currentToken = currentToken.Next;

            // Expect FROM keyword
            if (currentToken is not FromKeywordToken)
            {
                throw new UnexpectedTokenException(currentToken, typeof(FromKeywordToken));
            }

            currentToken = currentToken.Next;

            // Collect start expression tokens
            List<Token> startExpressionTokens = [];
            while (currentToken is not null and not ToKeywordToken)
            {
                startExpressionTokens.Add(currentToken);
                currentToken = currentToken.Next;
            }

            if (startExpressionTokens.Count == 0)
            {
                throw new UnexpectedTokenException(currentToken, "Expected expression after FROM");
            }

            // Build start expression
            rangeStartExpression = startExpressionTokens.Count == 1 && startExpressionTokens[0] is ValueToken startVal
                ? new LiteralExpression(startVal)
                : startExpressionTokens.Count == 1 && startExpressionTokens[0] is IdentifierToken startId
                ? new IdentifierExpression(startId)
                : BuildExpressionFromTokens(startExpressionTokens);

            // Expect TO keyword
            if (currentToken is not ToKeywordToken)
            {
                throw new UnexpectedTokenException(currentToken, typeof(ToKeywordToken));
            }

            currentToken = currentToken.Next;

            // Collect end expression tokens
            List<Token> endExpressionTokens = [];
            while (currentToken is not null and not ScopeStartToken and not AsKeywordToken)
            {
                endExpressionTokens.Add(currentToken);
                currentToken = currentToken.Next;
            }

            if (endExpressionTokens.Count == 0)
            {
                throw new UnexpectedTokenException(currentToken, "Expected expression after TO");
            }

            // Build end expression
            rangeEndExpression = endExpressionTokens.Count == 1 && endExpressionTokens[0] is ValueToken endVal
                ? new LiteralExpression(endVal)
                : endExpressionTokens.Count == 1 && endExpressionTokens[0] is IdentifierToken endId
                ? new IdentifierExpression(endId)
                : BuildExpressionFromTokens(endExpressionTokens);

            collectionExpression = rangeStartExpression;
            loopVariableName = GetAutomaticIndexName(nestingLevel);
            usedAutoGeneratedName = true;

            LoggerService.Logger.Debug($"RANGE FROM {rangeStartExpression} TO {rangeEndExpression}");

            // Check for AS keyword
            if (currentToken is AsKeywordToken)
            {
                currentToken = currentToken.Next;

                if (currentToken is not IdentifierToken customNameToken)
                {
                    throw new UnexpectedTokenException(currentToken, typeof(IdentifierToken));
                }

                loopVariableName = customNameToken.RawToken!.Text;
                usedAutoGeneratedName = false;
                currentToken = currentToken.Next;

                LoggerService.Logger.Debug($"Custom loop variable name for range: {loopVariableName}");
            }
        }
        // Check for array literal [start, end] - CYCLE [1, 5]
        else if (currentToken is BracketOpen)
        {
            isRangeLoop = true;
            currentToken = currentToken.Next;

            // Parse start value
            if (currentToken is ValueToken startVal)
            {
                rangeStartExpression = new LiteralExpression(startVal);
                currentToken = currentToken.Next;
            }
            else if (currentToken is IdentifierToken startId)
            {
                rangeStartExpression = new IdentifierExpression(startId);
                currentToken = currentToken.Next;
            }
            else
            {
                throw new UnexpectedTokenException(currentToken, "Expected value or identifier for range start");
            }

            // Expect comma
            if (currentToken is not CommaToken)
            {
                throw new UnexpectedTokenException(currentToken, typeof(CommaToken));
            }

            currentToken = currentToken.Next;

            // Parse end value
            if (currentToken is ValueToken endVal)
            {
                rangeEndExpression = new LiteralExpression(endVal);
                currentToken = currentToken.Next;
            }
            else if (currentToken is IdentifierToken endId)
            {
                rangeEndExpression = new IdentifierExpression(endId);
                currentToken = currentToken.Next;
            }
            else
            {
                throw new UnexpectedTokenException(currentToken, "Expected value or identifier for range end");
            }

            // Expect closing bracket
            if (currentToken is not BracketClosed)
            {
                throw new UnexpectedTokenException(currentToken, typeof(BracketClosed));
            }

            currentToken = currentToken.Next;

            collectionExpression = rangeStartExpression;
            loopVariableName = GetAutomaticIndexName(nestingLevel);
            usedAutoGeneratedName = true;

            LoggerService.Logger.Debug($"Array literal range: [{rangeStartExpression}, {rangeEndExpression}]");

            // Check for AS keyword
            if (currentToken is AsKeywordToken)
            {
                currentToken = currentToken.Next;

                if (currentToken is not IdentifierToken customNameToken)
                {
                    throw new UnexpectedTokenException(currentToken, typeof(IdentifierToken));
                }

                loopVariableName = customNameToken.RawToken!.Text;
                usedAutoGeneratedName = false;
                currentToken = currentToken.Next;

                LoggerService.Logger.Debug($"Custom loop variable name for array literal range: {loopVariableName}");
            }
        }
        // Check if this is a count-based loop (CYCLE <number>), expression-based (CYCLE n-2), or collection-based (CYCLE IN)
        else if (currentToken is ValueToken countToken)
        {
            // Could be: CYCLE 5 { ... } or CYCLE -5 TO 5 { ... }
            currentToken = currentToken.Next;

            // Check for TO keyword (range loop)
            if (currentToken is ToKeywordToken)
            {
                isRangeLoop = true;
                rangeStartExpression = new LiteralExpression(countToken);
                currentToken = currentToken.Next;

                // Get the end value
                if (currentToken is ValueToken endToken)
                {
                    rangeEndExpression = new LiteralExpression(endToken);
                    currentToken = currentToken.Next;
                }
                else if (currentToken is IdentifierToken endIdent)
                {
                    rangeEndExpression = new IdentifierExpression(endIdent);
                    currentToken = currentToken.Next;
                }
                else
                {
                    throw new UnexpectedTokenException(currentToken, "Expected value or identifier after TO");
                }

                // For range loops, we'll use the start expression as collection and store end in a special way
                collectionExpression = rangeStartExpression;
                loopVariableName = GetAutomaticIndexName(nestingLevel);
                usedAutoGeneratedName = true;

                LoggerService.Logger.Debug($"Range loop: {countToken.RawToken?.Text} TO {rangeEndExpression}");
            }
            else
            {
                // Simple count-based loop: CYCLE 5 { ... }
                isCountBased = true;
                collectionExpression = new LiteralExpression(countToken);
                loopVariableName = GetAutomaticIndexName(nestingLevel);
                usedAutoGeneratedName = true;

                LoggerService.Logger.Debug($"Count-based loop: {countToken.RawToken?.Text} iterations");
            }

            // Check for AS keyword to customize loop variable name
            if (currentToken is AsKeywordToken)
            {
                currentToken = currentToken.Next;

                if (currentToken is not IdentifierToken customNameToken)
                {
                    throw new UnexpectedTokenException(currentToken, typeof(IdentifierToken));
                }

                loopVariableName = customNameToken.RawToken!.Text;
                usedAutoGeneratedName = false; // User provided explicit name
                currentToken = currentToken.Next;

                LoggerService.Logger.Debug($"Custom loop variable name: {loopVariableName}");
            }
        }
        else if (currentToken is IdentifierToken)
        {
            // Could be: CYCLE iterations { ... }, CYCLE n-2 { ... }, or CYCLE 0 TO Array->Length { ... }
            List<Token> expressionTokens = [];

            // Collect tokens that could be part of an expression
            while (currentToken is not null and not ScopeStartToken and not AsKeywordToken and not ToKeywordToken)
            {
                expressionTokens.Add(currentToken);
                currentToken = currentToken.Next;
            }

            // Check for TO keyword (range loop with identifier start)
            if (currentToken is ToKeywordToken)
            {
                isRangeLoop = true;

                // Build start expression from collected tokens
                if (expressionTokens.Count == 1 && expressionTokens[0] is IdentifierToken singleIdent)
                {
                    rangeStartExpression = new IdentifierExpression(singleIdent);
                }
                else
                {
                    rangeStartExpression = BuildExpressionFromTokens(expressionTokens);
                }

                currentToken = currentToken.Next;

                // Collect end expression tokens
                List<Token> endExpressionTokens = [];
                while (currentToken is not null and not ScopeStartToken and not AsKeywordToken)
                {
                    endExpressionTokens.Add(currentToken);
                    currentToken = currentToken.Next;
                }

                // Build end expression
                if (endExpressionTokens.Count == 0)
                {
                    throw new UnexpectedTokenException(currentToken, "Expected expression after TO");
                }
                else if (endExpressionTokens.Count == 1)
                {
                    if (endExpressionTokens[0] is ValueToken endVal)
                    {
                        rangeEndExpression = new LiteralExpression(endVal);
                    }
                    else if (endExpressionTokens[0] is IdentifierToken endId)
                    {
                        rangeEndExpression = new IdentifierExpression(endId);
                    }
                    else
                    {
                        rangeEndExpression = BuildExpressionFromTokens(endExpressionTokens);
                    }
                }
                else
                {
                    rangeEndExpression = BuildExpressionFromTokens(endExpressionTokens);
                }

                // For range loops, we'll use the start expression as collection and store end in a special way
                collectionExpression = rangeStartExpression;
                loopVariableName = GetAutomaticIndexName(nestingLevel);
                usedAutoGeneratedName = true;

                LoggerService.Logger.Debug($"Range loop: {rangeStartExpression} TO {rangeEndExpression}");

                // Check for AS keyword to customize loop variable name
                if (currentToken is AsKeywordToken)
                {
                    currentToken = currentToken.Next;

                    if (currentToken is not IdentifierToken customNameToken)
                    {
                        throw new UnexpectedTokenException(currentToken, typeof(IdentifierToken));
                    }

                    loopVariableName = customNameToken.RawToken!.Text;
                    usedAutoGeneratedName = false; // User provided explicit name
                    currentToken = currentToken.Next;

                    LoggerService.Logger.Debug($"Custom loop variable name for range: {loopVariableName}");
                }
            }
            else
            {
                // Expression-based loop: CYCLE n - 2 { ... } or simple identifier: CYCLE iterations { ... }
                isCountBased = true;

                // If we only got one identifier, treat as simple variable reference
                if (expressionTokens.Count == 1 && expressionTokens[0] is IdentifierToken singleIdent)
                {
                    collectionExpression = new IdentifierExpression(singleIdent);
                    LoggerService.Logger.Debug($"Variable-based loop count: {singleIdent.RawToken?.Text}");
                }
                else
                {
                    // Build expression from tokens (e.g., "n - 2", "len / 2")
                    collectionExpression = BuildExpressionFromTokens(expressionTokens);
                    LoggerService.Logger.Debug(
                        $"Expression-based loop count: {string.Join(" ", expressionTokens.Select(t => t.RawToken?.Text))}");
                }

                loopVariableName = GetAutomaticIndexName(nestingLevel);
                usedAutoGeneratedName = true; // Initially assume auto-generated

                // Check for AS keyword to customize loop variable name
                if (currentToken is AsKeywordToken)
                {
                    currentToken = currentToken.Next;

                    if (currentToken is not IdentifierToken customNameToken)
                    {
                        throw new UnexpectedTokenException(currentToken, typeof(IdentifierToken));
                    }

                    loopVariableName = customNameToken.RawToken!.Text;
                    usedAutoGeneratedName = false; // User provided explicit name
                    currentToken = currentToken.Next;

                    LoggerService.Logger.Debug($"Custom loop variable name: {loopVariableName}");
                }
            }
        }
        else if (currentToken is InKeywordToken)
        {
            // Collection-based loop: CYCLE IN collection { ... }
            currentToken = currentToken.Next;

            // Parse the collection expression
            collectionExpression = ParseCollectionExpression(ref currentToken);

            LoggerService.Logger.Debug($"Collection expression: {collectionExpression}");

            loopVariableName = GetAutomaticIndexName(nestingLevel);
            usedAutoGeneratedName = true; // Initially assume auto-generated

            // Check for AS keyword to rename the loop variable
            if (currentToken is AsKeywordToken)
            {
                currentToken = currentToken.Next;

                if (currentToken is not IdentifierToken customNameToken)
                {
                    throw new UnexpectedTokenException(currentToken, typeof(IdentifierToken));
                }

                loopVariableName = customNameToken.RawToken!.Text;
                usedAutoGeneratedName = false; // User provided explicit name
                currentToken = currentToken.Next;

                LoggerService.Logger.Debug($"Custom loop variable name: {loopVariableName}");
            }
            else
            {
                LoggerService.Logger.Debug(
                    $"Automatic loop variable: {loopVariableName} (nesting level {nestingLevel})");
            }
        }
        else
        {
            throw new UnexpectedTokenException(currentToken, typeof(ValueToken), typeof(InKeywordToken));
        }

        // Expect opening brace for loop body
        if (currentToken is not ScopeStartToken)
        {
            if (currentToken == null)
            {
                throw new UnexpectedTokenException(cycleToken,
                    "Unexpected end of tokens, expected { to start loop body", typeof(ScopeStartToken));
            }

            throw new UnexpectedTokenException(currentToken, typeof(ScopeStartToken));
        }

        // Create the loop statement
        CycleLoopStatement loopStatement = new(collectionExpression, loopVariableName, nestingLevel)
        {
            StartToken = cycleToken,
            IsCountBased = isCountBased,
            IsWhileLoop = isWhileLoop,
            IsRangeLoop = isRangeLoop,
            RangeEndExpression = rangeEndExpression
        };

        // Create a new scope for the loop body
        Scope loopScope = new($"CYCLE_{loopVariableName}")
        {
            Type = ScopeType.Block,
            OuterScope = context.CurrentScope
        };

        // Register the loop variable as a dynamic variable in the loop scope
        loopScope.AddDynamicVariable(loopVariableName);

        // Create a new context - only increment nesting depth if we used an auto-generated name
        ProcessingContext loopContext = context.Clone();
        loopContext.CurrentScope = loopScope;
        loopContext.CycleNestingDepth = usedAutoGeneratedName
            ? context.CycleNestingDepth + 1  // Increment for auto-generated names (A, B, C...)
            : context.CycleNestingDepth;      // Keep same for explicit names (AS outer, AS inner, etc.)

        // Build the loop body scope
        _scopeBuilder.BuildScope(currentToken, loopScope, loopContext);

        loopStatement.LoopBody = loopScope;

        // Add the loop statement to the current scope
        context.CurrentScope.Statements.Add(loopStatement);

        LoggerService.Logger.Success(
            $"[CycleLoopProcessor] Registered CYCLE loop with variable '{loopVariableName}' in scope '{context.CurrentScope.ScopeName}'");

        // Find the closing brace to continue processing
        Token? nextToken = currentToken;
        int braceDepth = 1;
        while (nextToken != null && braceDepth > 0)
        {
            nextToken = nextToken.Next;
            if (nextToken is ScopeStartToken)
            {
                braceDepth++;
            }

            if (nextToken is ScopeEndToken)
            {
                braceDepth--;
            }
        }

        return nextToken == null
            ? throw new UnexpectedTokenException(cycleToken, "Unmatched braces in CYCLE loop - missing closing }",
                typeof(ScopeEndToken))
            : new TokenProcessingResult
            {
                NextToken = nextToken.Next ?? nextToken,
                ShouldValidateExpectations = false
            };
    }

    /// <summary>
    ///     Parses the collection expression (identifier, function call, or property access)
    /// </summary>
    private static Expression ParseCollectionExpression(ref Token? token)
    {
        if (token is IdentifierToken identifierToken)
        {
            // Simple identifier or function call
            if (identifierToken.Next is ParenthesisOpen)
            {
                // Function call returning a collection
                FunctionCallExpression funcCallExpr = new()
                {
                    FunctionName = identifierToken
                };

                token = identifierToken.Next; // Move to (
                token = token!.Next; // Move past (

                // Function call arguments are not yet supported in CYCLE loops

                // Skip to )
                while (token is not null and not ParenthesisClosed)
                {
                    token = token.Next;
                }

                if (token is ParenthesisClosed)
                {
                    token = token.Next;
                }

                return funcCallExpr;
            }

            // Simple collection variable
            IdentifierExpression expr = new(identifierToken);
            token = token.Next;
            return expr;
        }

        throw new NotImplementedException(
            $"Collection expression type {token?.GetType().Name} not yet supported in CYCLE loops");
    }

    /// <summary>
    ///     Gets the automatic index variable name based on nesting level
    ///     Level 0 = 'A', Level 1 = 'B', Level 2 = 'C', etc.
    /// </summary>
    private static string GetAutomaticIndexName(int nestingLevel)
    {
        if (nestingLevel < 26)
        {
            char indexChar = (char)('A' + nestingLevel);
            return indexChar.ToString();
        }

        // For deep nesting, use AA, AB, AC, etc.
        int firstChar = (nestingLevel / 26) - 1;
        int secondChar = nestingLevel % 26;
        return $"{(char)('A' + firstChar)}{(char)('A' + secondChar)}";
    }

    /// <summary>
    ///     Builds a binary expression from a list of tokens (e.g., "n - 2", "len / 2")
    ///     Supports simple binary expressions with +, -, *, /, %
    ///     Also handles parentheses around expressions
    /// </summary>
    private static Expression BuildExpressionFromTokens(List<Token> tokens)
    {
        if (tokens.Count == 0)
        {
            throw new InvalidOperationException("Cannot build expression from empty token list");
        }

        // Remove surrounding parentheses if present
        if (tokens.Count >= 2 &&
            tokens[0] is ParenthesisOpen &&
            tokens[^1] is ParenthesisClosed)
        {
            tokens = tokens.GetRange(1, tokens.Count - 2);
        }

        if (tokens.Count == 0)
        {
            throw new InvalidOperationException("Cannot build expression from empty token list");
        }

        if (tokens.Count == 1)
        {
            // Single token - should be identifier or value
            return TokenToExpression(tokens[0]);
        }

        // Simple binary expression: <left> <operator> <right>
        // For now, support only 3-token expressions
        if (tokens.Count == 3)
        {
            Expression left = TokenToExpression(tokens[0], "Expected identifier or value as left operand");
            Expression right = TokenToExpression(tokens[2], "Expected identifier or value as right operand");
            return new BinaryExpression(left, tokens[1], right);
        }

        throw new NotImplementedException($"Complex expressions with {tokens.Count} tokens not yet supported in CYCLE");
    }

    private static Expression TokenToExpression(Token token, string? errorMessage = null)
    {
        return token is IdentifierToken ident
            ? new IdentifierExpression(ident)
            : token is ValueToken val
            ? (Expression)new LiteralExpression(val)
            : throw new UnexpectedTokenException(token, errorMessage ?? "Expected identifier or value");
    }
}